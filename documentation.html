<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Agile JavaScript - Movie Database Documentation</title>

  <link rel="stylesheet" href="css/bootstrap.min.css">
  <link rel="stylesheet" href="css/bootstrap.media.css">
  <link rel="stylesheet" href="vendor/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="css/main.css">
</head>
<body>

<div class="container">
  <h1 class="page-header">
    Agile JavaScript
    <small>a codecentric AG workshop</small>
  </h1>
  <p class="well">
    If you are reading this, then you are probably here because one of the
    trainers has given you this URI. If not, then most of this information
    may not be of interest to you. Should you be interested in this
    workshop, please contact our
    <a href="mailto:agilejs@codecentric.de">training team</a> (workshop is
    available in German and English).
  </p>

  <h2>Build-Tool: Grunt</h2>
  <p>
    Probably the most important tool, when developing a JavaScript application,
    is <strong>Grunt</strong>. All steps, that are needed to verify, test and
    build the application, are defined as grunt-tasks. To see a list of
    available tasks, simply execute <code>grunt --help</code>:
    <pre>$ grunt --help
Available tasks
   simplemocha  Run tests with mocha *
        jshint  Validate files with JSHint. *
         watch  Run predefined tasks whenever watched files change.
         karma  Run browser unit- and integration-tests with karma. *
        server  Start the server for testing purposes. When used directly from
                command-line, be sure to specify the '--wait' option. Otherwise
                the process will exit immediately.
        travis  Alias for "jshint", "simplemocha", "karma:unit", "server",     
                "karma:integration" tasks.
           dev  Alias for "server", "watch" tasks.</pre>
    The configuration for all tasks lies in the <code>Gruntfile.js</code>. Custom tasks are loaded from the <code>tasks</code> directory.
  </p>
  
  <p>
    Some tasks are in fact multitasks. To execute only a single substep of a multitask, use ":" as separator. At the moment only jshint and karma are multitasks. The subtasks are: jshint:server, jshint:servertest, jshint:gruntfile, jshint:client, jshint:karmaIntegration and jshint:karmaUnit for jshint and karma:unit and karma:integration for karma</p>
  </p>
  
  <p>The most important grunt-tasks are <strong>travis</strong>
  and <strong>dev</strong> (in fact, these two include all other available
  tasks), but it can be useful to know about the other ones, too.</p>

  <h3>grunt travis</h3>
  <p>This task is executed during a build on Travis-CI. The following steps are performed:
    <ul>
      <li><strong>grunt jshint</strong>: Static code analysis for all project files.</li>
      <li><strong>grunt simplemocha</strong>: Unit-tests for server-side code.</li>
      <li><strong>grunt karma:unit</strong>: Unit-tests for client-side code (using karma and phantomjs).</li>
      <li><strong>grunt server</strong>: Start a server with our application (needed for integration-tests). Note, that the server keeps running until grunt itself exits. In particular, the server can be used by the subsequent integration-test task.</li>
      <li><strong>grunt karma:integration</strong>: Integration-tests using the server started by the precedent server-task.</li>
    </ul>
  </p>

  <h3>grunt dev</h3>
  <p>The <strong>dev</strong>-task is the most important task during local development. It has two functions:
    <ul>
      <li>It starts a server listening on port 3000. The server is automatically restarted whenever a file changes.</li>
      <li>It uses the watch task to execute jshint, simplemocha and karma:integration whenever a file changes.</li>
    </ul>
  </p>
  <pre>$ grunt dev
Running "server" task

DEBUG: Running node-supervisor with
DEBUG:   program 'server/server.js'
...

Running "watch" task
Express server listening on port 3000
Activated neo4j auto-indexing
Added property type to neo4j auto-indexing.
...</pre>
    
  <h3>grunt simplemocha</h3>
  <p>Executes the unit-tests for server-side code. The unit-tests are in the <code>test/server</code> directory. The simplemocha task uses a simple console-reporter. Unfortunately, the log-output of the server-code is also directly written to the console. This makes it difficult to detect test-errors, but it is the easiest way to make all necessary information available during Travis-CI runs (note, that only console-output is archived for Travis-CI runs).
  </p>
  <pre>$ grunt simplemocha
Running "simplemocha:all" (simplemocha) task

  getMovie
    ◦ should return an empty list when neo returns null: [2013-10-06 19:21:49.369] [DEBUG] routes/movies - Retrieving a list of all movies
[2013-10-06 19:21:49.370] [DEBUG] routes/movies - Successfully loaded 0 movies.
    ✓ should return an empty list when neo returns null
...

  4 passing (21ms)</pre>

  <h3>grunt jshint</h3>
  <p>
    The <strong>jshint</strong> tasks runs static code on all files. With the available subtasks, you can run static code analysis only on specific code files.
    <pre>$ grunt jshint
Running "jshint:server" (jshint) task
>> 6 files lint free.

Running "jshint:servertest" (jshint) task
>> 2 files lint free.

Running "jshint:gruntfile" (jshint) task
>> 1 file lint free.

Running "jshint:client" (jshint) task
>> 2 files lint free.

Running "jshint:karmaIntegration" (jshint) task
>> 1 file lint free.

Running "jshint:karmaUnit" (jshint) task
>> 1 file lint free.

Done, without errors.</pre>
  </p>
  
  <h3>grunt watch</h3>
  <p>
    Watch for file changes and execute the tasks jshing, simplemocha and karma:unit whenever a file is changed.
    <pre>$ grunt watch
Running "watch" task
Waiting...OK
>> File "server/app.js" changed.

Running "jshint:server" (jshint) task
...
Running "simplemocha:all" (simplemocha) task
...
Running "karma:unit" (karma) task
...

Done, without errors.
Completed in 2.105s at Sun Oct 06 2013 19:47:50 GMT+0200 (CEST) - Waiting...</pre>
  </p>
  
  <h3>grunt server --wait</h3>
  <p>
    The server task starts a NodeJS server running the movie-database application. If used directly from command-line (and not from within other tasks), be sure to add the <code>--wait</code> option. Otherwise grunt will exit and the server will be shutdown immediately.
  </p>
  <p>
    The server-tasks is used for three purposes: First, the travis task include a call to the server task to start the application for the end-to-end tests. Second, the dev-task uses it to start the server for local development. And last, you can use it directly from command-line (with the --wait option), if you do not want the overhead of the dev task.
  </p>
  <pre>$ grunt server --wait
Running "server" task
...
Express server listening on port 3000
...
</pre>

  <h3>grunt karma [--debug]</h3>
  <p>
    Execute tests using karma. By default karma uses PhantomJS as (headless) browser. The test-results are printed to console. The karma-configuration-files are located in <code>test/karma</code>.
  </p>
  <p><strong>If you want to debug karma-tests, you can use the <code>--debug</code> option. </strong> With this option, the tests will be executed using the Chrome-browser. Moreover, karma will not exit after the first test-run, but the browser will remain open instead. If you click the "Debug" button, you can use your browser's debugger to execute your tests step by step.
  </p>
  <p>
    There are two subtasks:
    <ul>
      <li><strong>grunt karma:unit [--debug]</strong>: The client-side unit-tests are located in the <code>test/karma/unit</code> directory. The test-framework in use is simplemocha. If you debug these tests, the browser-window will remain blank. <strong>Take a look at the JavaScript console</strong> of your browser to see the test results.</li>
      <li><strong>karma:integration [--debug]</strong>: The integration (or end-to-end-tests) are based on angular-scenario. Make sure, that you have your application running on port 3000 when executing this task!</li>
    </ul>
  </p>
  
  <h2>Client-Side: AngularJS</h2>
  <p>

  <h2>Server-Side: Node.JS, Express.JS</h2>
  <p>
    The server-implementation has two responsibilities: On the one hand it serves static files for the AngularJS Frontend. On the other hand it provides (REST-)interface to our persistence layer.
  </p>
  
  <h3>Static Files</h3>
  <p>
    Every request that points directly to a file inside the <code>client</code> directory is simply answered by serving exactly the requested file. E.g. a request to <code>/js/lib/angular.js</code> will result in the file <code>/client/js/lib/angular.js</code> being served. <strong>Moreover, any other request, that does not include a <code>Accept: application/json</code> header will result in the <code>index.html</code> file being served!</strong> For more information on this behaviour, see the <a href="https://github.com/bripkens/connect-history-api-fallback">History API Fallback</a>.
  </p>

  <h3>REST-API</h3>
  <p> The easiest way to explain the REST-API is by example (using curl): </p>
  <pre>$ curl -v -XGET \
    -H "Accept: application/json" \
    http://localhost:3000/movies
> GET /movies HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:3000
> Accept: application/json
> 
< HTTP/1.1 200 OK
< X-Powered-By: Express
< Cache-Control: no-cache
< Content-Type: application/json; charset=utf-8
< Content-Length: 1916
< ETag: "499684216"
< Date: Sun, 06 Oct 2013 18:06:14 GMT
< Connection: keep-alive
< 
<[
<  {
<    "id": "b2251a97-ea3c-4b7f-a01d-125817babceb",
<    "type": "movie",
<    "description": "When Batman, Gordon...",
<    "title": "The Dark Knight"
<  },
<  {
<    "id": "e7b1ccf2-68ca-4595-83e4-2bed1f59c846",
<    "type": "movie",
<    "description": "Eight years on, ... ",
<    "title": "The Dark Knight Rises"
<  },
<  ...
<]

$ curl -v -XGET \
    -H "Accept: application/json" \
    http://localhost:3000/movies/41d18190-16ca-48a1-83c2-7bdfe540d901
> GET /movies/41d18190-16ca-48a1-83c2-7bdfe540d901 HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:3000
> Accept: application/json
> 
< HTTP/1.1 200 OK
< X-Powered-By: Express
< Cache-Control: no-cache
< Content-Type: application/json; charset=utf-8
< Content-Length: 271
< Date: Sun, 06 Oct 2013 18:07:35 GMT
< Connection: keep-alive
< 
< {
<  "id": "41d18190-16ca-48a1-83c2-7bdfe540d901",
<  "type": "movie",
<  "description": "Sequel to the 2002 film...",
<  "title": "Undisputed II: Last Man Standing"
< }

$ curl -v -XPOST \
   -H "Content-Type: application/json" \
   -H "Accept: application/json" \
   --data '{"title":"A new movie"}' \
   http://localhost:3000/movies
> POST /movies HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:3000
> Content-Type: application/json
> Accept: application/json
> Content-Length: 23
> 
< HTTP/1.1 201 Created
< X-Powered-By: Express
< Cache-Control: no-cache
< Location: http://localhost:3000/movies/2fc69159-a744-4d46-a8bf-d62457fb64a2
< Content-Type: application/json; charset=utf-8
< Content-Length: 95
< Date: Sun, 06 Oct 2013 18:09:09 GMT
< Connection: keep-alive
< 
< {
<  "id": "2fc69159-a744-4d46-a8bf-d62457fb64a2",
<  "type": "movie",
<  "title": "A new movie"
<}</pre>

  <h2>Persistence: Neo4J</h2>
  <p>
    Normally, you shouldn't have to worry about neo4j. Once the service is started, everything should work out of the box. You can check if neo4j is running by navigating to <a href="http://localhost:7474/">http://localhost:7474</a>. If you wonder about the log-lines <pre>Activated neo4j auto-indexing. 
Added property title to neo4j auto-indexing.
...
Added property type to neo4j auto-indexing.</pre>
    that you can see when the NodeJS server starts, they initialise the necessary Neo4J indexes. By default Neo4J does not index node-properties (at least in version 1.x - this will change with version 2). To free you of the necessary configuration, this is done automatically during the movie-database startup.
  </p>
  <p>
    To clear the database, you only need to delete the directory <code>data/graph.db</code>.
    Please note that you should only do this once Neo4j is shut down (at the very
    least, Neo4j requires a restart in order to properly work again after deleting
    the directory). Also, please note that you should create the node auto index
    after resetting the database (as mentioned above). A convenient way to do this
    is the following bash script. It needs to be executed in your Neo4j installation
    directory.
    <pre># stop the server, delete the current graph, restart it and create the auto index
sudo /etc/init.d/neo4j-service stop && \
sudo rm -rf data/graph.db/ && \
sudo /etc/init.d/neo4j-service start && \
bin/neo4j-shell -c "index --create node_auto_index -t Node"</pre>
  </p>
      
</div>

</body>
</html>
